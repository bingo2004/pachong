-- MySQL dump 10.13  Distrib 5.7.22, for Linux (x86_64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	5.7.22-0ubuntu0.17.10.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `posts`
--

DROP TABLE IF EXISTS `posts`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `posts` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` mediumtext,
  `body` mediumtext,
  `body_html` mediumtext,
  `timestamp` datetime DEFAULT NULL,
  `author_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `author_id` (`author_id`),
  KEY `ix_posts_timestamp` (`timestamp`),
  CONSTRAINT `posts_ibfk_1` FOREIGN KEY (`author_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=126 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `posts`
--

LOCK TABLES `posts` WRITE;
/*!40000 ALTER TABLE `posts` DISABLE KEYS */;
INSERT INTO `posts` VALUES (107,'mysql数据库无法插入中文字符','转载自：[mysql数据库无法插入中文字符](https://www.cnblogs.com/liushao/p/6370326.html)\r\n\r\n#分析原因：\r\n\r\n这是因为之前修改了数据库的编码，但数据表的编码却没有跟着改变导致的。\r\n\r\n安装mysql 时，使用的是latin编码（随后修改为utf8）。建的数据表是在latin编码下建立的。而jsp页面使用的是utf8，所以无法插入数据。\r\n\r\n \r\n\r\n##1.修改mysql数据库编码\r\n\r\n修改MySQL安装目录下的my.ini文件\r\n\r\n`default-character-set=utf8`\r\n\r\n`character-set-server=utf8`\r\n\r\n\r\n\r\n然后重启MySQL服务，MySQL 没有重启的命令，要先停止，然后再启动。\r\n\r\n这样就确保了，mysql中的编码类型。\r\n\r\n`show variables like \'char%\';`或`status;`\r\n\r\n\r\n##2.解决方法 \r\n\r\n设置表的编码格式，执行\r\n\r\n`alter table 数据表名 CONVERT TO CHARACTER SET utf8`\r\n\r\n','<p>转载自：<a href=\"https://www.cnblogs.com/liushao/p/6370326.html\" rel=\"nofollow\">mysql数据库无法插入中文字符</a></p>\n<h1>分析原因：</h1>\n<p>这是因为之前修改了数据库的编码，但数据表的编码却没有跟着改变导致的。</p>\n<p>安装mysql 时，使用的是latin编码（随后修改为utf8）。建的数据表是在latin编码下建立的。而jsp页面使用的是utf8，所以无法插入数据。</p>\n<h2>1.修改mysql数据库编码</h2>\n<p>修改MySQL安装目录下的my.ini文件</p>\n<p><code>default-character-set=utf8</code></p>\n<p><code>character-set-server=utf8</code></p>\n<p>然后重启MySQL服务，MySQL 没有重启的命令，要先停止，然后再启动。</p>\n<p>这样就确保了，mysql中的编码类型。</p>\n<p><code>show variables like \'char%\';</code>或<code>status;</code></p>\n<h2>2.解决方法</h2>\n<p>设置表的编码格式，执行</p>\n<p><code>alter table 数据表名 CONVERT TO CHARACTER SET utf8</code></p>','2018-05-11 03:59:15',888),(108,'Ubuntu上部署flask应用：NginX+uWSGI+supervisor','#服务器上NginX部署flask应用\r\n\r\n这部分内容网上讲解的很多，很多人的博客中都有介绍，但是在参考的过程中也遇到了很多问题。终于在参考了一些前人的经验成功部署，给自己做一个记录。\r\n\r\n本文涉及到的内容包括：Nginx、uWSGI、flask框架\r\n\r\n## 0 主要参考文章：\r\n\r\n+ [Serving Flask with Nginx](https://vladikk.com/2013/09/12/serving-flask-with-nginx-on-ubuntu/)\r\n+ [阿里云部署Flask+WSGI+Nginx详解](https://www.cnblogs.com/Ray-liang/p/4173923.html)\r\n+ [Flask+uwsgi+Nginx部署应用](https://www.jianshu.com/p/84978157c785)\r\n\r\n## 1 前提\r\n\r\n     sudo apt-get install pip\r\n     sudo pip install virtualenv\r\n     virturalenv venv\r\n     source venv/bin/active\r\n     pip install flask\r\n     pip install uwsgi\r\n\r\n## 2 Nginx安装\r\n\r\nUbuntu中apt-get安装Nginx，首先添加repositories\r\n\r\n    sudo add-apt-repository ppa:nginx/stable\r\n\r\n注：如果 “add-apt-repository” 命令不存在，需要首先安装 “software-properties-common” 包: sudo apt-get install software-properties-common\r\n\r\n更新升级包：\r\n\r\n    sudo apt-get update && sudo apt-get upgrade\r\n\r\n安装并启动 Nginx:\r\n\r\n    sudo apt-get install nginx\r\n    sudo /etc/init.d/nginx start\r\n\r\n\r\n## 3 uWSGI安装\r\n\r\n    sudo apt-get install build-essential python python-dev\r\n    pip install uwsgi\r\n\r\n## 4 配置\r\n\r\nflask框架里面利用manager.py启动文件\r\n\r\n    #!/usr/bin/env python\r\n    import os\r\n\r\n    from app import create_app\r\n    from flask.ext.script import Manager, Shell\r\n\r\n    # 通过配置创建 app \r\n    app = create_app(os.getenv(\'FLASK_CONFIG\') or \'default\')\r\n    manager = Manager(app)\r\n\r\n    def make_shell_context():\r\n        return dict(app=app)\r\n\r\n    manager.add_command(\"shell\", Shell(make_context=make_shell_context))\r\n\r\n    @manager.command\r\n    def deploy():\r\n        \"\"\"Run deployment tasks.\"\"\"\r\n        pass\r\n\r\n    if __name__ == \'__main__\':\r\n        manager.run()\r\n\r\n\r\n\r\n##配置Nginx\r\n\r\n删除默认设置\r\n\r\n    sudo rm /etc/nginx/sites-enabled/default\r\n\r\n将`config_nginx.conf`配置到/etc/nginx/conf目录中\r\n\r\n    server {\r\n      listen 80;\r\n      server_name localhost;\r\n      \r\n      location / {\r\n        include uwsgi_params;\r\n        uwsgi_pass	127.0.0.1:8001;\r\n        uwsgi_param	UWSGI_PYHOME /home/bingo/git/flasky/venv\r\n        uwsgi_param	UWSGI_CHDIR /home/bingo/git/flasky\r\n        uwsgi_param	UWSGI_SCRIPT manager:app;\r\n      }\r\n    }\r\n\r\n`sudo ln -s /home/bingo/git/flasky/config_nginx.conf /etc/nginx/conf`\r\n\r\n#配置uWSGI\r\n\r\nconfig_uwsgi.ini文件：\r\n\r\n    [uwsgi]\r\n    socket = 127.0.0.1:8001 \r\n    chdir = /home/bingo/git/flasky\r\n    master = True\r\n    home = /home/bingo/git/flasky/venv\r\n    wsgi-file = manager.py\r\n    callable = app\r\n    processes = 4\r\n    threads = 2\r\n    buffer-size = 32768\r\n    stats = 127.0.0.1:9191\r\n\r\n# 5 安装配置supervisor\r\n\r\n使用supervisor引导uWSGI。安装：\r\n\r\n    sudo apt-get install supervisor\r\n\r\nsupervisor的全局配置文件在`/etc/supervisor/supervisor.conf`中，一般不改动，新建一个文件flask_supervisor.conf放在`/etc/supervisor/conf.d`目录下:\r\n\r\n    [program:blog] \r\n    # 启动命令入口 \r\n    command=/home/bingo/git/flasky/venv/bin/uwsgi /home/bingo/git/flasky/config_uwsgi.ini            \r\n    # 命令程序所在目录 \r\n    directory=/home/bingo/git/flasky\r\n    #运行命令的用户名 \r\n    user=bingo\r\n    autostart=true\r\n    autorestart=true\r\n    #日志地址 \r\n    stdout_logfile=/home/bingo/git/flasky/logs/uwsgi_supervisor.log\r\n\r\n启动supervisor服务：sudo service supervisor start\r\n\r\n','<h1>服务器上NginX部署flask应用</h1>\n<p>这部分内容网上讲解的很多，很多人的博客中都有介绍，但是在参考的过程中也遇到了很多问题。终于在参考了一些前人的经验成功部署，给自己做一个记录。</p>\n<p>本文涉及到的内容包括：Nginx、uWSGI、flask框架</p>\n<h2>0 主要参考文章：</h2>\n<ul>\n<li><a href=\"https://vladikk.com/2013/09/12/serving-flask-with-nginx-on-ubuntu/\" rel=\"nofollow\">Serving Flask with Nginx</a></li>\n<li><a href=\"https://www.cnblogs.com/Ray-liang/p/4173923.html\" rel=\"nofollow\">阿里云部署Flask+WSGI+Nginx详解</a></li>\n<li><a href=\"https://www.jianshu.com/p/84978157c785\" rel=\"nofollow\">Flask+uwsgi+Nginx部署应用</a></li>\n</ul>\n<h2>1 前提</h2>\n<pre><code> sudo apt-get install pip\n sudo pip install virtualenv\n virturalenv venv\n source venv/bin/active\n pip install flask\n pip install uwsgi\n</code></pre>\n<h2>2 Nginx安装</h2>\n<p>Ubuntu中apt-get安装Nginx，首先添加repositories</p>\n<pre><code>sudo add-apt-repository ppa:nginx/stable\n</code></pre>\n<p>注：如果 “add-apt-repository” 命令不存在，需要首先安装 “software-properties-common” 包: sudo apt-get install software-properties-common</p>\n<p>更新升级包：</p>\n<pre><code>sudo apt-get update &amp;&amp; sudo apt-get upgrade\n</code></pre>\n<p>安装并启动 Nginx:</p>\n<pre><code>sudo apt-get install nginx\nsudo /etc/init.d/nginx start\n</code></pre>\n<h2>3 uWSGI安装</h2>\n<pre><code>sudo apt-get install build-essential python python-dev\npip install uwsgi\n</code></pre>\n<h2>4 配置</h2>\n<p>flask框架里面利用manager.py启动文件</p>\n<pre><code>#!/usr/bin/env python\nimport os\n\nfrom app import create_app\nfrom flask.ext.script import Manager, Shell\n\n# 通过配置创建 app \napp = create_app(os.getenv(\'FLASK_CONFIG\') or \'default\')\nmanager = Manager(app)\n\ndef make_shell_context():\n    return dict(app=app)\n\nmanager.add_command(\"shell\", Shell(make_context=make_shell_context))\n\n@manager.command\ndef deploy():\n    \"\"\"Run deployment tasks.\"\"\"\n    pass\n\nif __name__ == \'__main__\':\n    manager.run()\n</code></pre>\n<h2>配置Nginx</h2>\n<p>删除默认设置</p>\n<pre><code>sudo rm /etc/nginx/sites-enabled/default\n</code></pre>\n<p>将<code>config_nginx.conf</code>配置到/etc/nginx/conf目录中</p>\n<pre><code>server {\n  listen 80;\n  server_name localhost;\n\n  location / {\n    include uwsgi_params;\n    uwsgi_pass  127.0.0.1:8001;\n    uwsgi_param UWSGI_PYHOME /home/bingo/git/flasky/venv\n    uwsgi_param UWSGI_CHDIR /home/bingo/git/flasky\n    uwsgi_param UWSGI_SCRIPT manager:app;\n  }\n}\n</code></pre>\n<p><code>sudo ln -s /home/bingo/git/flasky/config_nginx.conf /etc/nginx/conf</code></p>\n<h1>配置uWSGI</h1>\n<p>config_uwsgi.ini文件：</p>\n<pre><code>[uwsgi]\nsocket = 127.0.0.1:8001 \nchdir = /home/bingo/git/flasky\nmaster = True\nhome = /home/bingo/git/flasky/venv\nwsgi-file = <a href=\"http://manager.py\" rel=\"nofollow\">manager.py</a>\ncallable = app\nprocesses = 4\nthreads = 2\nbuffer-size = 32768\nstats = 127.0.0.1:9191\n</code></pre>\n<h1>5 安装配置supervisor</h1>\n<p>使用supervisor引导uWSGI。安装：</p>\n<pre><code>sudo apt-get install supervisor\n</code></pre>\n<p>supervisor的全局配置文件在<code>/etc/supervisor/supervisor.conf</code>中，一般不改动，新建一个文件flask_supervisor.conf放在<code>/etc/supervisor/conf.d</code>目录下:</p>\n<pre><code>[program:blog] \n# 启动命令入口 \ncommand=/home/bingo/git/flasky/venv/bin/uwsgi /home/bingo/git/flasky/config_uwsgi.ini            \n# 命令程序所在目录 \ndirectory=/home/bingo/git/flasky\n#运行命令的用户名 \nuser=bingo\nautostart=true\nautorestart=true\n#日志地址 \nstdout_logfile=/home/bingo/git/flasky/logs/uwsgi_supervisor.log\n</code></pre>\n<p>启动supervisor服务：sudo service supervisor start</p>','2018-05-15 05:28:46',888),(110,'flask框架使用MySQL遇到的问题','**flask-mysqldb**\r\n\r\n　　错误解决方案：\r\n\r\n　　１.检查系统是否安装了libmysqlclient-dev，没有安装的话使用sudo apt-get install libmysqlclient-dev安装\r\n\r\n　　２.sudo updatedb，locate mysql_config找到mysql_config的安装目录/usr/bin/mysql_config\r\n\r\n　　３.在mysql-python源码包下找到：setup_posix.py 文件，然后找到文件中的 mysql_config.path 将其值改为：/usr/bin/mysql_config,然后 sudo python setup.py install\r\n\r\n　　４.重新安装flask-mysqldb　pip install flask-mysqldb　　\r\n','<p><strong>flask-mysqldb</strong></p>\n<p>错误解决方案：</p>\n<p>１.检查系统是否安装了libmysqlclient-dev，没有安装的话使用sudo apt-get install libmysqlclient-dev安装</p>\n<p>２.sudo updatedb，locate mysql_config找到mysql_config的安装目录/usr/bin/mysql_config</p>\n<p>３.在mysql-python源码包下找到：<a href=\"http://setup_posix.py\" rel=\"nofollow\">setup_posix.py</a> 文件，然后找到文件中的 mysql_config.path 将其值改为：/usr/bin/mysql_config,然后 sudo python <a href=\"http://setup.py\" rel=\"nofollow\">setup.py</a> install</p>\n<p>４.重新安装flask-mysqldb　pip install flask-mysqldb　　</p>','2018-05-01 08:22:10',888),(111,'python中的下划线','\r\n\r\n**单个下划线(_)\r\n\r\n1. 解释器中:交互解释器中最后一次执行语句的返回结果\r\n\r\n2. 用作被丢弃的名称\r\n\r\n3. ？\r\n\r\n**单下划线前缀：\r\n\r\n名称私有\r\n\r\n**双下划线前缀：\r\n\r\npython默认改写__spam为_classname__spam,其中classname是当前类名\r\n\r\n**前后都带双下划线的名称：\r\n\r\npython中的特殊方法名，惯例，确保python中的名称不会与用户自定义的名称冲突。\r\n\r\n[参考](https://segmentfault.com/a/1190000002611411)','<p>**单个下划线(_)</p>\n<ol>\n<li>\n<p>解释器中:交互解释器中最后一次执行语句的返回结果</p>\n</li>\n<li>\n<p>用作被丢弃的名称</p>\n</li>\n<li>\n<p>？</p>\n</li>\n</ol>\n<p>**单下划线前缀：</p>\n<p>名称私有</p>\n<p>**双下划线前缀：</p>\n<p>python默认改写<strong>spam为_classname</strong>spam,其中classname是当前类名</p>\n<p>**前后都带双下划线的名称：</p>\n<p>python中的特殊方法名，惯例，确保python中的名称不会与用户自定义的名称冲突。</p>\n<p><a href=\"https://segmentfault.com/a/1190000002611411\" rel=\"nofollow\">参考</a></p>','2018-04-24 08:22:10',888),(112,'python中的time模块','# time模块\r\n\r\ntime模块是包含各方面对时间操作的函数. 尽管这些常常有效但不是所有方法在任意平台中有效. time用struct_time表示时间\r\n\r\n    import time\r\n    time.struct_time(tm_year=2015, tm_mon=4, tm_mday=24, \r\n      tm_hour=14, tm_min=17, tm_sec=26, \r\n      tm_wday=4, tm_yday=114, tm_isdst=0)\r\n    print time.localtime()\r\n    print time.localtime().tm_year\r\n\r\n\r\n    time.time(): 返回一个时间戳\r\n    time.asctime([t]): 转换gmtime()和localtime()返回的元组或struct_time为string.\r\n    time.clock(): 在第一次调用的时候, 返回程序运行的时间. 第二次之后返回与之前的间隔.\r\n    time.ctime([secs]): 将时间戳转换为时间字符串, 如没有提供则返回当前的时间字符串,并与asctime(localtime())一样.\r\n    time.gmtime([secs]): 将时间戳转化为, UTC 时区的struct_time.\r\n    time.localtime([secs]): 类似gmtime()但会把他转换成本地时区.\r\n    time.mktime(t): struct_time 转化为时间戳.\r\n    time.sleep(secs): 线程推迟指定时间, 以秒为单位.\r\n    time.strftime(format[,t]): 根据参数转换一个sturc_time或元组为字符串.\r\n    time.strptime(string[, format]): 与strftime相反,返回一个struct_time.','<h1>time模块</h1>\n<p>time模块是包含各方面对时间操作的函数. 尽管这些常常有效但不是所有方法在任意平台中有效. time用struct_time表示时间</p>\n<pre><code>import time\ntime.struct_time(tm_year=2015, tm_mon=4, tm_mday=24, \n  tm_hour=14, tm_min=17, tm_sec=26, \n  tm_wday=4, tm_yday=114, tm_isdst=0)\nprint time.localtime()\nprint time.localtime().tm_year\n\n\ntime.time(): 返回一个时间戳\ntime.asctime([t]): 转换gmtime()和localtime()返回的元组或struct_time为string.\ntime.clock(): 在第一次调用的时候, 返回程序运行的时间. 第二次之后返回与之前的间隔.\ntime.ctime([secs]): 将时间戳转换为时间字符串, 如没有提供则返回当前的时间字符串,并与asctime(localtime())一样.\ntime.gmtime([secs]): 将时间戳转化为, UTC 时区的struct_time.\ntime.localtime([secs]): 类似gmtime()但会把他转换成本地时区.\ntime.mktime(t): struct_time 转化为时间戳.\ntime.sleep(secs): 线程推迟指定时间, 以秒为单位.\ntime.strftime(format[,t]): 根据参数转换一个sturc_time或元组为字符串.\ntime.strptime(string[, format]): 与strftime相反,返回一个struct_time.\n</code></pre>','2018-04-23 08:22:10',888),(113,'python 发送邮件','# sendmail 的安装与配置\r\n\r\nhttps://blog.csdn.net/xin_yu_xin/article/details/45115723\r\n\r\nhttps://blog.csdn.net/xin_yu_xin/article/details/45115723\r\n\r\n# 遇到的问题：\r\nhttp://blog.51cto.com/lizhenliang/1875330\r\n\r\n## 在vpn中，端口25不通,表现为smtplib.connect卡住\r\n\r\n    stmp = smtplib.SMTP(\"smtp.163.com\", 25)\r\n    smtp.login(\'\',\'\')\r\n\r\n   改为：\r\n\r\n    stmp = smtplib.SMTP_SSL(\"smtp.163.com\", 465)\r\n    smtp.login(\'\',\'\')\r\n\r\n参考：\r\n[1](https://segmentfault.com/q/1010000007661948)\r\n[2](https://stackoverflow.com/questions/6979678/python-smtp-errno-10060)','<h1>sendmail 的安装与配置</h1>\n<p><a href=\"https://blog.csdn.net/xin_yu_xin/article/details/45115723\" rel=\"nofollow\">https://blog.csdn.net/xin_yu_xin/article/details/45115723</a></p>\n<p><a href=\"https://blog.csdn.net/xin_yu_xin/article/details/45115723\" rel=\"nofollow\">https://blog.csdn.net/xin_yu_xin/article/details/45115723</a></p>\n<h1>遇到的问题：</h1>\n<p><a href=\"http://blog.51cto.com/lizhenliang/1875330\" rel=\"nofollow\">http://blog.51cto.com/lizhenliang/1875330</a></p>\n<h2>在vpn中，端口25不通,表现为smtplib.connect卡住</h2>\n<pre><code>stmp = smtplib.SMTP(\"<a href=\"http://smtp.163.com\" rel=\"nofollow\">smtp.163.com</a>\", 25)\nsmtp.login(\'\',\'\')\n</code></pre>\n<p>改为：</p>\n<pre><code>stmp = smtplib.SMTP_SSL(\"<a href=\"http://smtp.163.com\" rel=\"nofollow\">smtp.163.com</a>\", 465)\nsmtp.login(\'\',\'\')\n</code></pre>\n<p>参考：\n<a href=\"https://segmentfault.com/q/1010000007661948\" rel=\"nofollow\">1</a>\n<a href=\"https://stackoverflow.com/questions/6979678/python-smtp-errno-10060\" rel=\"nofollow\">2</a></p>','2018-04-22 08:22:10',888),(114,'Linux 后台任务和进程查看(1)','我们可以让当前任务不再占用终端，移动到后台，去挂起或执行了，而仍然可以继续使用终端，继续来敲击命令。\r\n\r\n## 先看进程ps –l\r\n\r\n第一行的PID是进程id，那PPID则是父进程ID，第二列的S是status状态的意思。\r\n\r\n## S，T,  R\r\n\r\nS：是指sleep睡眠状态，其实计算机的进程有很多时间都是在睡眠的，因为一般情况下，多任务执行是轮流分片执行的，大量的任务是不可能一起去执行的。因为硬件条件有限，一般的就是1个，两个，好些的是四个，8个cpu等等。那么几个根本不会同时执行多个任务\r\n\r\nT：是挂起状态，挂起了就停止，在后台什么都不做，和睡眠状态不一样，挂起的话，即使时间片到了也不会被调度，就是什么都不做而干等着。只要不占据终端就能放到后台执行。\r\n\r\n 注意：\r\n\r\n Vi编辑器是全屏幕的编辑器，一旦运行，就必须占用终端。\r\n\r\nR：是运行状态（running）\r\n\r\n其实还有一种状态Z，叫僵尸状态，使用ps –e（查看所有进程状态，而ps默认只看本终端的进程）\r\n\r\n东西太多，我们使用管道命令，使用grep命令去查找带Z的行。\r\n\r\n    dashuai@ubuntu:~$ ps -el | grep Z  \r\n\r\n不过，人品不错，没有发现，其实一般情况下，一些程序员的程序写的不咋滴，就会出现一些僵尸进程出来，就是说一个程序本来已经结束了，但是他还占用着资源不释放！资源没有被回收。这样的进程就是僵尸进程。当然，比较常见的是STR这三个状态\r\n\r\n补充：ps –f 完整的命令执行名称查看（full），可以显示完整的命令。\r\n\r\n## 进一步看后台任务的例子 \r\n\r\n比如sleep命令是睡眠命令，可以在后台运行，不会妨碍终端。\r\n\r\n如果在命令后加一个符号&即可让命令在后台执行。\r\n\r\n有一个专门查看后台任务的命令，jobs命令查看后台任务\r\n\r\n    dashuai@ubuntu:~$ jobs  \r\n\r\n发现每个后台任务都有编号（先后顺序编号），还有+和—，可以看作是优先级，+级别最高，什么都没有级别最低。这三个任务都已经完毕。\r\n \r\n\r\n fg把带+的任务调到前台来执行，我再重新弄几个后台任务\r\n\r\n    dashuai@ubuntu:~$ jobs  \r\n     [1]- Running                 sleep 1000&  \r\n     [2]+ Running                 sleep 2000&  \r\n\r\nRunning是正在后台执行的意思。\r\n\r\nfg（front）默认是把带+的任务调到前台，而fg加任务编号是将此任务调到前台来执行\r\n\r\nbg（back）把暂停中的的后台任务，放到后台执行起来，同理默认是带+的任务带到后台执行！或者bg指定任务编号，来解除挂起状态。\r\n\r\n终止某个当前的任务：一般可以用ctrl+c来终止。但是有些不行，比如vi就不能用ctrl+c来终止，当然也可以明确使用终止命令 kill 进程编号，通过发信号让进程终止\r\n\r\n如果想要终止后台任务，也可以加上后台的编号，为了防止误会，加上%\r\n\r\nkill %任务编号  终止后台某个正在执行的任务','<p>我们可以让当前任务不再占用终端，移动到后台，去挂起或执行了，而仍然可以继续使用终端，继续来敲击命令。</p>\n<h2>先看进程ps –l</h2>\n<p>第一行的PID是进程id，那PPID则是父进程ID，第二列的S是status状态的意思。</p>\n<h2>S，T,  R</h2>\n<p>S：是指sleep睡眠状态，其实计算机的进程有很多时间都是在睡眠的，因为一般情况下，多任务执行是轮流分片执行的，大量的任务是不可能一起去执行的。因为硬件条件有限，一般的就是1个，两个，好些的是四个，8个cpu等等。那么几个根本不会同时执行多个任务</p>\n<p>T：是挂起状态，挂起了就停止，在后台什么都不做，和睡眠状态不一样，挂起的话，即使时间片到了也不会被调度，就是什么都不做而干等着。只要不占据终端就能放到后台执行。</p>\n<p>注意：</p>\n<p>Vi编辑器是全屏幕的编辑器，一旦运行，就必须占用终端。</p>\n<p>R：是运行状态（running）</p>\n<p>其实还有一种状态Z，叫僵尸状态，使用ps –e（查看所有进程状态，而ps默认只看本终端的进程）</p>\n<p>东西太多，我们使用管道命令，使用grep命令去查找带Z的行。</p>\n<pre><code>dashuai@ubuntu:~$ ps -el | grep Z\n</code></pre>\n<p>不过，人品不错，没有发现，其实一般情况下，一些程序员的程序写的不咋滴，就会出现一些僵尸进程出来，就是说一个程序本来已经结束了，但是他还占用着资源不释放！资源没有被回收。这样的进程就是僵尸进程。当然，比较常见的是STR这三个状态</p>\n<p>补充：ps –f 完整的命令执行名称查看（full），可以显示完整的命令。</p>\n<h2>进一步看后台任务的例子</h2>\n<p>比如sleep命令是睡眠命令，可以在后台运行，不会妨碍终端。</p>\n<p>如果在命令后加一个符号&amp;即可让命令在后台执行。</p>\n<p>有一个专门查看后台任务的命令，jobs命令查看后台任务</p>\n<pre><code>dashuai@ubuntu:~$ jobs\n</code></pre>\n<p>发现每个后台任务都有编号（先后顺序编号），还有+和—，可以看作是优先级，+级别最高，什么都没有级别最低。这三个任务都已经完毕。</p>\n<p>fg把带+的任务调到前台来执行，我再重新弄几个后台任务</p>\n<pre><code>dashuai@ubuntu:~$ jobs  \n [1]- Running                 sleep 1000&amp;  \n [2]+ Running                 sleep 2000&amp;\n</code></pre>\n<p>Running是正在后台执行的意思。</p>\n<p>fg（front）默认是把带+的任务调到前台，而fg加任务编号是将此任务调到前台来执行</p>\n<p>bg（back）把暂停中的的后台任务，放到后台执行起来，同理默认是带+的任务带到后台执行！或者bg指定任务编号，来解除挂起状态。</p>\n<p>终止某个当前的任务：一般可以用ctrl+c来终止。但是有些不行，比如vi就不能用ctrl+c来终止，当然也可以明确使用终止命令 kill 进程编号，通过发信号让进程终止</p>\n<p>如果想要终止后台任务，也可以加上后台的编号，为了防止误会，加上%</p>\n<p>kill %任务编号  终止后台某个正在执行的任务</p>','2018-04-10 08:22:10',888),(115,'Vim使用技巧备忘','## 批量缩进\r\n\r\n    :3,33>\r\n\r\n    3到33行缩进\r\n\r\n## 直接粘贴的方式会导致代码丢失和缩进错乱等情况:\r\n\r\n解决办法：\r\nvim进入paste模式，命令如下：\r\n\r\n    :set paste\r\n\r\n进入paste模式之后，再按i进入插入模式，进行复制、粘贴就很正常了。 \r\n\r\n命令模式下，输入\r\n\r\n    :set nopaste\r\n\r\n解除paste模式。','<h2>批量缩进</h2>\n<pre><code>:3,33&gt;\n\n3到33行缩进\n</code></pre>\n<h2>直接粘贴的方式会导致代码丢失和缩进错乱等情况:</h2>\n<p>解决办法：\nvim进入paste模式，命令如下：</p>\n<pre><code>:set paste\n</code></pre>\n<p>进入paste模式之后，再按i进入插入模式，进行复制、粘贴就很正常了。 </p>\n<p>命令模式下，输入</p>\n<pre><code>:set nopaste\n</code></pre>\n<p>解除paste模式。</p>','2018-04-18 08:22:10',888),(116,'Linux 多个文件中查找字符串','\r\n\r\n    find <directory> -type f -name \"*.c\" | xargs grep \"<strings>\"\r\n\r\n`<directory>`是你要找的文件夹；如果是当前文件夹可以省略\r\n\r\n`-type f `意思是只找文件\r\n\r\n`-name \"*.c\"  `表示只找C语言写的代码，从而避免去查binary；也可以不写，表示找所有文件\r\n\r\n`<strings>`是你要找的某个字符串','<pre><code>find &lt;directory&gt; -type f -name \"*.c\" | xargs grep \"&lt;strings&gt;\"\n</code></pre>\n<p><code>&lt;directory&gt;</code>是你要找的文件夹；如果是当前文件夹可以省略</p>\n<p><code>-type f</code>意思是只找文件</p>\n<p><code>-name \"*.c\"</code>表示只找C语言写的代码，从而避免去查binary；也可以不写，表示找所有文件</p>\n<p><code>&lt;strings&gt;</code>是你要找的某个字符串</p>','2018-04-21 08:22:10',888),(117,'Linux 后台任务，运行，关闭，查看 (2)','\r\n\r\nfg、bg、jobs、&、nohup、ctrl+z、ctrl+c 命令\r\n\r\n## &\r\n\r\n加在一个命令的最后，可以把这个命令放到后台执行，如\r\n\r\n    watch  -n 10 sh  test.sh  &  #每10s在后台执行一次test.sh脚本\r\n## ctrl + z\r\n\r\n可以将一个正在前台执行的命令放到后台，并且处于暂停状态。\r\n\r\n## jobs\r\n\r\n查看当前有多少在后台运行的命令\r\n\r\njobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。\r\n\r\n## fg\r\n\r\n将后台中的命令调至前台继续运行。如果后台中有多个命令，可以用fg %jobnumber（是命令编号，不是进程号）将选中的命令调出。\r\n\r\n\r\n## bg\r\n\r\n将一个在后台暂停的命令，变成在后台继续执行。如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出。\r\n\r\n## kill\r\n\r\n法子1：通过jobs命令查看job号（假设为num），然后执行kill %num\r\n法子2：通过ps命令查看job的进程号（PID，假设为pid），然后执行kill pid\r\n前台进程的终止：Ctrl+c\r\n\r\n##  nohup\r\n\r\n如果让程序始终在后台执行，即使关闭当前的终端也执行（之前的&做不到），这时候需要nohup。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。关闭中断后，在另一个终端jobs已经无法看到后台跑得程序了，此时利用ps（进程查看命令）\r\n\r\n    ps -aux | grep \"test.sh\"  #a:显示所有程序 u:以用户为主的格式来显示 x:显示所有程序，不以终端机来区分\r\n','<p>fg、bg、jobs、&amp;、nohup、ctrl+z、ctrl+c 命令</p>\n<h2>&amp;</h2>\n<p>加在一个命令的最后，可以把这个命令放到后台执行，如</p>\n<pre><code>watch  -n 10 sh  <a href=\"http://test.sh\" rel=\"nofollow\">test.sh</a>  &amp;  #每10s在后台执行一次test.sh脚本\n</code></pre>\n<h2>ctrl + z</h2>\n<p>可以将一个正在前台执行的命令放到后台，并且处于暂停状态。</p>\n<h2>jobs</h2>\n<p>查看当前有多少在后台运行的命令</p>\n<p>jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated。但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识。</p>\n<h2>fg</h2>\n<p>将后台中的命令调至前台继续运行。如果后台中有多个命令，可以用fg %jobnumber（是命令编号，不是进程号）将选中的命令调出。</p>\n<h2>bg</h2>\n<p>将一个在后台暂停的命令，变成在后台继续执行。如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出。</p>\n<h2>kill</h2>\n<p>法子1：通过jobs命令查看job号（假设为num），然后执行kill %num\n法子2：通过ps命令查看job的进程号（PID，假设为pid），然后执行kill pid\n前台进程的终止：Ctrl+c</p>\n<h2>nohup</h2>\n<p>如果让程序始终在后台执行，即使关闭当前的终端也执行（之前的&amp;做不到），这时候需要nohup。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。关闭中断后，在另一个终端jobs已经无法看到后台跑得程序了，此时利用ps（进程查看命令）</p>\n<pre><code>ps -aux | grep \"<a href=\"http://test.sh\" rel=\"nofollow\">test.sh</a>\"  #a:显示所有程序 u:以用户为主的格式来显示 x:显示所有程序，不以终端机来区分\n</code></pre>','2018-04-11 08:22:10',888),(118,'Linux 工具rename','\r\n\r\n将main1.c重命名为main.c\r\n\r\nrename main1.c main.c main1.c\r\n\r\nrename支持通配符\r\n\r\n?  可替代单个字符\r\n*  可替代多个字符\r\n[charset]  可替代charset集中的任意单个字符\r\n\r\n文件夹中有这些文件foo1, ..., foo9, foo10, ..., foo278\r\n\r\n如果使用rename foo foo0 foo?，会把foo1到foo9的文件重命名为foo01到foo09，重命名的文件只是有4个字符长度名称的文件，文件名中的foo被替换为foo0。\r\n\r\n如果使用rename foo foo0 foo??，foo01到foo99的所有文件都被重命名为foo001到foo099，只重命名5个字符长度名称的文件，文件名中的foo被替换为foo0。\r\n\r\n如果使用rename foo foo0 foo*，foo001到foo278的所有文件都被重命名为foo0001到foo0278，所有以foo开头的文件都被重命名。\r\n\r\n如果使用rename foo0 foo foo0[2]*，从foo0200到foo0278的所有文件都被重命名为foo200到foo278，文件名中的foo0被替换为foo。\r\n\r\nrename支持正则表达式\r\n\r\n字母的替换\r\n\r\n		rename \'s/AA/aa/\' *  //把文件名中的AA替换成aa\r\n\r\n修改文件的后缀\r\n\r\n		rename \'s//.html//.php/\' *     //把.html 后缀的改成 .php后缀\r\n\r\n批量添加文件后缀\r\n\r\n		rename \'s/$//.txt/\' *     //把所有的文件名都以txt结尾\r\n\r\n批量删除文件名\r\n\r\n		rename \'s//.txt//\' *      //把所有以.txt结尾的文件名的.txt删掉','<p>将main1.c重命名为main.c</p>\n<p>rename main1.c main.c main1.c</p>\n<p>rename支持通配符</p>\n<p>?  可替代单个字符\n*  可替代多个字符\n[charset]  可替代charset集中的任意单个字符</p>\n<p>文件夹中有这些文件foo1, ..., foo9, foo10, ..., foo278</p>\n<p>如果使用rename foo foo0 foo?，会把foo1到foo9的文件重命名为foo01到foo09，重命名的文件只是有4个字符长度名称的文件，文件名中的foo被替换为foo0。</p>\n<p>如果使用rename foo foo0 foo??，foo01到foo99的所有文件都被重命名为foo001到foo099，只重命名5个字符长度名称的文件，文件名中的foo被替换为foo0。</p>\n<p>如果使用rename foo foo0 foo*，foo001到foo278的所有文件都被重命名为foo0001到foo0278，所有以foo开头的文件都被重命名。</p>\n<p>如果使用rename foo0 foo foo0[2]*，从foo0200到foo0278的所有文件都被重命名为foo200到foo278，文件名中的foo0被替换为foo。</p>\n<p>rename支持正则表达式</p>\n<p>字母的替换</p>\n<pre><code>    rename \'s/AA/aa/\' *  //把文件名中的AA替换成aa\n</code></pre>\n<p>修改文件的后缀</p>\n<pre><code>    rename \'s//.html//.php/\' *     //把.html 后缀的改成 .php后缀\n</code></pre>\n<p>批量添加文件后缀</p>\n<pre><code>    rename \'s/$//.txt/\' *     //把所有的文件名都以txt结尾\n</code></pre>\n<p>批量删除文件名</p>\n<pre><code>    rename \'s//.txt//\' *      //把所有以.txt结尾的文件名的.txt删掉\n</code></pre>','2018-04-01 08:22:10',888),(119,'Python中set的基本使用','\r\n\r\nset类是在python的sets模块中，现在使用的python2.3中，不需要导入sets模块可以直接创建集合。\r\n\r\n		>>>set(\'boy\')\r\n		>>>set([\'y\', \'b\', \'o\'])\r\n\r\n集合添加、删除\r\n\r\n集合的添加有两种常用方法，分别是add和update。\r\n集合add方法：是把要传入的元素做为一个整个添加到集合中，例如：\r\n\r\n		>>> a = set(\'boy\')\r\n		>>> a.add(\'python\')\r\n		>>> a\r\n		set([\'y\', \'python\', \'b\', \'o\'])\r\n\r\n创建\r\n第一种\r\n\r\n		set1 = {\"1\", \"2\"}\r\n		{\'1\', \'2\'}\r\n		print(type(set1))\r\n\r\n第二种\r\n\r\n		list1 = [\"1\", \"2\", \"2\", \"1\"]\r\n		set2 = set(list1)\r\n		print(set2)\r\n		{\'1\', \'2\'}\r\n		<class \'set\'>\r\n\r\n集合update方法：是把要传入的元素拆分，做为个体传入到集合中，例如：\r\n\r\n		>>> a = set(\'boy\')\r\n		>>> a.update(\'python\')\r\n		>>> a\r\n		set([\'b\', \'h\', \'o\', \'n\', \'p\', \'t\', \'y\'])\r\n\r\n集合删除操作方法：remove\r\n\r\n		set([\'y\', \'python\', \'b\', \'o\'])\r\n		>>> a.remove(\'python\')\r\n		>>> a\r\n		set([\'y\', \'b\', \'o\'])\r\n\r\n    >>> 清除素有内容\r\n    s.clear()\r\n\r\n    >>> 两个集合的差集\r\n    s1 = {32, 12, 34}\r\n    s2 = {12, 43, 23}\r\n    >>> s1中存在，s2中不存在\r\n    print(s1.difference(s2))\r\n    >>> {32, 34}\r\n\r\n    >>> 对称差集\r\n    print(s1.symmetric_difference(s2))\r\n    >>> {32, 34, 43, 23}\r\n    >>> difference和symmetric_different会生成新一个结果，而different_update 和 symmetic_different_update会覆盖之前集合\r\n\r\n    >>> 移除元素 如果元素不存在，不会报错 remove 如果元素不存在，会报错\r\n    s1.discard(32)\r\n    print(s1)\r\n    >>> {34, 12}\r\n\r\n    >>> 集合pop随机移除某个元素并且获取那个参数,集合pop没有参数\r\n    re2 = s2.pop()\r\n    print(re2)\r\n    >>> 43\r\n    s3 = {11, 22, 33}\r\n    s4 = {44, 33, 22}\r\n\r\n    >>> 交集\r\n    print(s3.intersection(s4))\r\n    >>> {33, 22}\r\n\r\n    >>> 判断两个集合有没有交集,有返回true 无返回false\r\n    print(s3)\r\n    print(s4)\r\n    print(s3.isdisjoint(s4))\r\n    >>> False 怎么是false 这不是有交集吗\r\n\r\n    >>> 并集\r\n    print(s3.union(s4))\r\n    >>> {33, 22, 11, 44}\r\n\r\n    >>> update 批量更新\r\n    li = [21, 4, 2, 312]\r\n    s3.update(li)\r\n    print(s3)\r\n    {33, 2, 4, 11, 21, 22, 312}','<p>set类是在python的sets模块中，现在使用的python2.3中，不需要导入sets模块可以直接创建集合。</p>\n<pre><code>    &gt;&gt;&gt;set(\'boy\')\n    &gt;&gt;&gt;set([\'y\', \'b\', \'o\'])\n</code></pre>\n<p>集合添加、删除</p>\n<p>集合的添加有两种常用方法，分别是add和update。\n集合add方法：是把要传入的元素做为一个整个添加到集合中，例如：</p>\n<pre><code>    &gt;&gt;&gt; a = set(\'boy\')\n    &gt;&gt;&gt; a.add(\'python\')\n    &gt;&gt;&gt; a\n    set([\'y\', \'python\', \'b\', \'o\'])\n</code></pre>\n<p>创建\n第一种</p>\n<pre><code>    set1 = {\"1\", \"2\"}\n    {\'1\', \'2\'}\n    print(type(set1))\n</code></pre>\n<p>第二种</p>\n<pre><code>    list1 = [\"1\", \"2\", \"2\", \"1\"]\n    set2 = set(list1)\n    print(set2)\n    {\'1\', \'2\'}\n    &lt;class \'set\'&gt;\n</code></pre>\n<p>集合update方法：是把要传入的元素拆分，做为个体传入到集合中，例如：</p>\n<pre><code>    &gt;&gt;&gt; a = set(\'boy\')\n    &gt;&gt;&gt; a.update(\'python\')\n    &gt;&gt;&gt; a\n    set([\'b\', \'h\', \'o\', \'n\', \'p\', \'t\', \'y\'])\n</code></pre>\n<p>集合删除操作方法：remove</p>\n<pre><code>    set([\'y\', \'python\', \'b\', \'o\'])\n    &gt;&gt;&gt; a.remove(\'python\')\n    &gt;&gt;&gt; a\n    set([\'y\', \'b\', \'o\'])\n\n&gt;&gt;&gt; 清除素有内容\ns.clear()\n\n&gt;&gt;&gt; 两个集合的差集\ns1 = {32, 12, 34}\ns2 = {12, 43, 23}\n&gt;&gt;&gt; s1中存在，s2中不存在\nprint(s1.difference(s2))\n&gt;&gt;&gt; {32, 34}\n\n&gt;&gt;&gt; 对称差集\nprint(s1.symmetric_difference(s2))\n&gt;&gt;&gt; {32, 34, 43, 23}\n&gt;&gt;&gt; difference和symmetric_different会生成新一个结果，而different_update 和 symmetic_different_update会覆盖之前集合\n\n&gt;&gt;&gt; 移除元素 如果元素不存在，不会报错 remove 如果元素不存在，会报错\ns1.discard(32)\nprint(s1)\n&gt;&gt;&gt; {34, 12}\n\n&gt;&gt;&gt; 集合pop随机移除某个元素并且获取那个参数,集合pop没有参数\nre2 = s2.pop()\nprint(re2)\n&gt;&gt;&gt; 43\ns3 = {11, 22, 33}\ns4 = {44, 33, 22}\n\n&gt;&gt;&gt; 交集\nprint(s3.intersection(s4))\n&gt;&gt;&gt; {33, 22}\n\n&gt;&gt;&gt; 判断两个集合有没有交集,有返回true 无返回false\nprint(s3)\nprint(s4)\nprint(s3.isdisjoint(s4))\n&gt;&gt;&gt; False 怎么是false 这不是有交集吗\n\n&gt;&gt;&gt; 并集\nprint(s3.union(s4))\n&gt;&gt;&gt; {33, 22, 11, 44}\n\n&gt;&gt;&gt; update 批量更新\nli = [21, 4, 2, 312]\ns3.update(li)\nprint(s3)\n{33, 2, 4, 11, 21, 22, 312}\n</code></pre>','2018-03-31 08:22:10',888),(120,'instance method VS class method VS static method','[参考文献](https://realpython.com/instance-class-and-static-methods-demystified/)\r\n\r\n\r\n		class MyClass:\r\n				def method(self):\r\n						return \'instance method called\', self\r\n\r\n				@classmethod\r\n				def classmethod(cls):\r\n						return \'class method called\', cls\r\n\r\n				@staticmethod\r\n				def staticmethod():\r\n						return \'static method called\'\r\n\r\n\r\n','<p><a href=\"https://realpython.com/instance-class-and-static-methods-demystified/\" rel=\"nofollow\">参考文献</a></p>\n<pre><code>    class MyClass:\n            def method(self):\n                    return \'instance method called\', self\n\n            @classmethod\n            def classmethod(cls):\n                    return \'class method called\', cls\n\n            @staticmethod\n            def staticmethod():\n                    return \'static method called\'\n</code></pre>','2018-03-17 08:22:10',888),(121,'安装配置Privoxy','\r\n\r\n    sudo apt-get install privoxy -y\r\n\r\n### 修改配置文件\r\n\r\n    sudo cp /etc/privoxy/config /etc/privoxy/config.bak\r\n    sudo vim /etc/privoxy/config\r\n\r\n找到 listen-address 确保有这行代码 listen-address 127.0.0.1:8118\r\n*如果失败，尝试去掉这一行，在办公室机器就是去掉这一行之后成功的\r\n\r\n找到 forward-socks5 确保有这行代码(没有自己加) forward-socks5 / 127.0.0.1:1080 .\r\n*注释掉这一行后，可以恢复非privoxy连接\r\n\r\n### 启动\r\n\r\n    sudo service privoxy start\r\n    sudo service privoxy status\r\n\r\n### 配置转发\r\n\r\n    sudo vim ~/.bashrc\r\n\r\n在最后添加如下代码：\r\n\r\n    export http_proxy=\"http://127.0.0.1:8118\"\r\n    export https_proxy=\"http://127.0.0.1:8118\"\r\n\r\n### 重载配置\r\n\r\n    source ~/.bashrc\r\n    \r\n### 测试\r\n\r\n    wget http://www.google.com\r\n    \r\n--2018-04-01 11:23:21--  http://www.google.com/\r\n正在连接 127.0.0.1:8118... 已连接。\r\n已发出 Proxy 请求，正在等待回应... 200 OK','<pre><code>sudo apt-get install privoxy -y\n</code></pre>\n<h3>修改配置文件</h3>\n<pre><code>sudo cp /etc/privoxy/config /etc/privoxy/config.bak\nsudo vim /etc/privoxy/config\n</code></pre>\n<p>找到 listen-address 确保有这行代码 listen-address 127.0.0.1:8118\n*如果失败，尝试去掉这一行，在办公室机器就是去掉这一行之后成功的</p>\n<p>找到 forward-socks5 确保有这行代码(没有自己加) forward-socks5 / 127.0.0.1:1080 .\n*注释掉这一行后，可以恢复非privoxy连接</p>\n<h3>启动</h3>\n<pre><code>sudo service privoxy start\nsudo service privoxy status\n</code></pre>\n<h3>配置转发</h3>\n<pre><code>sudo vim ~/.bashrc\n</code></pre>\n<p>在最后添加如下代码：</p>\n<pre><code>export http_proxy=\"http://127.0.0.1:8118\"\nexport https_proxy=\"http://127.0.0.1:8118\"\n</code></pre>\n<h3>重载配置</h3>\n<pre><code>source ~/.bashrc\n</code></pre>\n<h3>测试</h3>\n<pre><code>wget <a href=\"http://www.google.com\" rel=\"nofollow\">http://www.google.com</a>\n</code></pre>\n<p>--2018-04-01 11:23:21--  <a href=\"http://www.google.com/\" rel=\"nofollow\">http://www.google.com/</a>\n正在连接 127.0.0.1:8118... 已连接。\n已发出 Proxy 请求，正在等待回应... 200 OK</p>','2018-03-10 08:22:10',888),(122,'Linux中 tar压缩与解压缩','\r\n\r\n* -c 建立压缩文档\r\n* -x 解压\r\n* -z 有gzip属性\r\n* -v 显示所有过程\r\n* -f 最后一个，接文件档案名字\r\n\r\n例如：\r\n\r\n    tar -czf file.tar.gz *.jpg\r\n    tar -xzf file.tar','<ul>\n<li>-c 建立压缩文档</li>\n<li>-x 解压</li>\n<li>-z 有gzip属性</li>\n<li>-v 显示所有过程</li>\n<li>-f 最后一个，接文件档案名字</li>\n</ul>\n<p>例如：</p>\n<pre><code>tar -czf file.tar.gz *.jpg\ntar -xzf file.tar\n</code></pre>','2018-03-05 08:22:10',888),(123,'SSH连接远程服务器','\r\n### 远程连接\r\n\r\n    #!/bin/bash\r\n    ssh -o StrictHostKeyChecking=no root@****\r\n\r\n### 上传本地到服务器\r\n\r\n    scp /path/filename username@servername:/path/\r\n    scp -r /path/local_dir username@servername:path/remote_dir\r\n    \r\n### 从服务器下载到本地\r\n\r\n    scp username@servername:/path/filename /path/\r\n    scp -r username@servername:/path/remote_dir /path/local_dir\r\n    \r\n### 登录水木乱码\r\n\r\n    luit -encoding gbk ssh root@***','<h3>远程连接</h3>\n<pre><code>#!/bin/bash\nssh -o StrictHostKeyChecking=no root@****\n</code></pre>\n<h3>上传本地到服务器</h3>\n<pre><code>scp /path/filename username@servername:/path/\nscp -r /path/local_dir username@servername:path/remote_dir\n</code></pre>\n<h3>从服务器下载到本地</h3>\n<pre><code>scp username@servername:/path/filename /path/\nscp -r username@servername:/path/remote_dir /path/local_dir\n</code></pre>\n<h3>登录水木乱码</h3>\n<pre><code>luit -encoding gbk ssh root@***\n</code></pre>','2018-03-01 08:22:10',888),(124,'uWSGI error: unavailable_modifier_requested','nginx配合使用 uwsgi时，出现error\r\n`unavailable modifier requested: 0`\r\n\r\n解决办法：\r\n[stackoverflow](https://stackoverflow.com/questions/10748108/nginx-uwsgi-unavailable-modifier-requested-0)\r\n\r\nInstalling the python plugin for uwsgi:\r\n\r\n`apt-get install uwsgi-plugin-python`\r\n for python 2 or\r\n `apt-get install uwsgi-plugin-python3`\r\n  for python 3\r\n\r\n  and adding `plugins = python` to the individual uwsgi app config solves this problem.\r\n\r\n**注：**因为使用的是supervisor 监控的uwsgi ，故需要修改的supervisor中的配置，请根据你的uwsgi启动位置进行修改\r\n\r\n如果直接在ini配置文件中，直接命令行启动uwsgi时有效，supervisor启动时无效。','<p>nginx配合使用 uwsgi时，出现error\n<code>unavailable modifier requested: 0</code></p>\n<p>解决办法：\n<a href=\"https://stackoverflow.com/questions/10748108/nginx-uwsgi-unavailable-modifier-requested-0\" rel=\"nofollow\">stackoverflow</a></p>\n<p>Installing the python plugin for uwsgi:</p>\n<p><code>apt-get install uwsgi-plugin-python</code>\n for python 2 or\n <code>apt-get install uwsgi-plugin-python3</code>\n  for python 3</p>\n<p>and adding <code>plugins = python</code> to the individual uwsgi app config solves this problem.</p>\n<p><strong>注：</strong>因为使用的是supervisor 监控的uwsgi ，故需要修改的supervisor中的配置，请根据你的uwsgi启动位置进行修改</p>\n<p>如果直接在ini配置文件中，直接命令行启动uwsgi时有效，supervisor启动时无效。</p>','2018-05-14 01:32:37',888),(125,'排序算法总结暨Python实现','# 一、算法及程序实现\r\n\r\n##0 参考：\r\n\r\n* [十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/articles/7674659.html)\r\n* 《算法导论》\r\n* [Python 代码性能优化技巧](https://www.ibm.com/developerworks/cn/linux/l-cn-python-optim/)\r\n\r\n##1 冒泡\r\n\r\n* 比较相邻的元素。如果第一个比第二个大，就交换它们两个；\r\n* 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\r\n* 针对所有的元素重复以上的步骤，除了最后一个；\r\n* 重复步骤1~3，直到排序完成。\r\n\r\n        def bubbleSort(l):\r\n            for i in range(len(l)-1):\r\n                for j in range(i+1,len(l)):\r\n                    if l[i]>l[j]:\r\n                        l[i],l[j]=l[j],l[i]\r\n            return l\r\n\r\n![冒泡算法演示](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif)\r\n\r\n##2 选择排序\r\n\r\n* 在未排序序列中找到最小元素，存放到排序序列的末尾位置\r\n* 然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。\r\n* 不断重复，直到所有元素均排序完毕。 \r\n\r\n\r\n        #coding:utf-8\r\n        def selectionSort(l):\r\n            for i in range(len(l)-1):\r\n                Index = i#无序区的起始点\r\n                m = i\r\n                for j in range(Index,len(l)):\r\n                    if l[j]<l[m]:\r\n                        m=j\r\n                if not m==Index:\r\n                    l[m],l[Index] = l[Index],l[m]\r\n            return l\r\n\r\n##3 插入排序（Insertion Sort）\r\n\r\n* 从第一个元素开始，该元素可以认为已经被排序；\r\n* 取出下一个元素，在已经排序的元素序列中从后向前扫描；\r\n* 如果该元素（已排序）大于新元素，将该元素移到下一位置；\r\n* 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\r\n* 将新元素插入到该位置后；\r\n* 重复步骤2~5。\r\n\r\n\r\n        def insertSort(l):\r\n            for i in range(1,len(l)):\r\n                Index = i\r\n                for j in range(i-1,-1,-1):\r\n                    if l[j]>l[Index]:\r\n                        l[j],l[Index]=l[Index],l[j]\r\n                        Index -= 1\r\n                    else:\r\n                        continue\r\n            return l\r\n\r\n##4 希尔排序（Shell Sort）\r\n1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。\r\n\r\n先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：\r\n\r\n* 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；\r\n* 按增量序列个数k，对序列进行k 趟排序；\r\n* 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\r\n\r\n        def shellSort(l):\r\n            gap = len(l)/2\r\n            while(gap):\r\n                for i in range(gap):\r\n                    for j in range(gap+i,len(l),gap):\r\n                        Index = j\r\n                        for k in range(j-gap,-1,-gap):\r\n                            if l[Index]<l[k]:\r\n                                l[Index],l[k]=l[k],l[Index]\r\n                                Index-=1\r\n                            else:\r\n                                continue\r\n                gap /= 2\r\n            return l\r\n\r\n##5 归并排序（Merge Sort）\r\n\r\n归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 \r\n\r\n* 把长度为n的输入序列分成两个长度为n/2的子序列；\r\n* 对这两个子序列分别采用归并排序；\r\n* 将两个排序好的子序列合并成一个最终的排序序列。\r\n\r\n\r\n        def mergeSort(l):\r\n            length = len(l)\r\n            if length<=1:\r\n                return l\r\n            l1 = mergeSort(l[:length/2])\r\n            l2 = mergeSort(l[length/2:])\r\n            i=0\r\n            j=0\r\n            l_return = []\r\n            while 1:\r\n                if i>=len(l1):\r\n                    l_return.extend(l2[j:])\r\n                    break\r\n                if j>=len(l2):\r\n                    l_return.extend(l1[i:])\r\n                    break\r\n                if l1[i]<l2[j]:\r\n                    l_return.append(l1[i])\r\n                    i += 1\r\n                else:\r\n                    l_return.append(l2[j])\r\n                    j += 1\r\n            return l_return\r\n\r\n##6 快速排序（Quick Sort）\r\n\r\n快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。\r\n\r\n快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：\r\n\r\n* 从数列中挑出一个元素，称为 “基准”（pivot）；\r\n* 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\r\n* 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\r\n\r\n        def quickSort(l):\r\n            if len(l)<=1:\r\n                return l\r\n            i=1\r\n            j=len(l)-1\r\n            while 1:\r\n                for q in xrange(j,-1,-1):\r\n                    if l[q]<=l[0]:\r\n                        break\r\n                j = q\r\n                for p in xrange(i,len(l)):\r\n                    if l[p]>l[0]:\r\n                        break\r\n                i = p\r\n                if i>=j:\r\n                    break\r\n                l[i],l[j] = l[j],l[i]\r\n            if j!=0:\r\n                l[0],l[j]=l[j],l[0]\r\n            return quickSort(l[:q])+[l[q]]+quickSort(l[q+1:])\r\n\r\n##7 堆排序（Heap Sort）\r\n\r\n堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\r\n\r\n* 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；\r\n* 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；\r\n* 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。\r\n\r\n\r\n        length = 0\r\n\r\n        def buildMaxHeap(l):\r\n            global length\r\n            length = len(l)\r\n            for i in range(length/2-1, -1, -1):\r\n                maxHeapify(l, i)\r\n\r\n        def maxHeapify(l,i):\r\n            left = 2*i +1\r\n            right = 2*i +2\r\n            largest = i\r\n\r\n            if left<length and l[left]>l[largest]:\r\n                largest = left\r\n            if right<length and l[right]>l[largest]:\r\n                largest = right\r\n            if largest != i:\r\n                l[i], l[largest] = l[largest], l[i]\r\n                maxHeapify(l,largest)\r\n\r\n        def heapSort(l):\r\n            buildMaxHeap(l)\r\n            global length\r\n\r\n            for i in range(len(l)-1,-1,-1):\r\n                l[0],l[i] = l[i],l[0]\r\n                length -= 1\r\n                maxHeapify(l,0)\r\n            return l\r\n\r\n\r\n##8 计数排序（Counting Sort）\r\n\r\n计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。\r\n\r\n* 找出待排序的数组中最大和最小的元素；\r\n* 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；\r\n* 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；\r\n* 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。\r\n\r\n\r\n        def countingSort(a, maxValue):\r\n            c = [0] * (maxValue+1)\r\n            b = [0] * len(a)\r\n            for i in xrange(len(a)):\r\n                c[a[i]] += 1\r\n            for i in xrange(1,maxValue+1):\r\n                c[i] += c[i-1]\r\n            for j in xrange(len(a)-1,-1,-1):\r\n                b[c[a[j]]-1] = a[j]\r\n                c[a[j]] -= 1\r\n            return b\r\n\r\n##9 基数排序（Radix Sort）\r\n\r\n基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。\r\n\r\n* 取得数组中的最大数，并取得位数；\r\n* arr为原始数组，从最低位开始取每个位组成radix数组；\r\n* 对radix进行计数排序（利用计数排序适用于小范围数的特点）；\r\n\r\n\r\n        def radixSort(l):\r\n            d = len(str(max(l)))\r\n            for i in range(d):\r\n                buf = [[] for m in range(10)]\r\n                for n in l:\r\n                    k = n//(10**i)%10\r\n                    buf[k].append(n)\r\n                l = []\r\n                for j in range(10):\r\n                    l.extend(buf[j])\r\n            return l\r\n\r\n\r\n##10 桶排序（Bucket Sort）\r\n\r\n桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。\r\n\r\n* 设置一个定量的数组当作空桶；\r\n* 遍历输入数据，并且把数据一个一个放到对应的桶里去；\r\n* 对每个不是空的桶进行排序；\r\n* 从不是空的桶里把排好序的数据拼接起来。\r\n\r\n\r\n        from insertSort import insertSort\r\n        def bucketSort(l,bucketSize = 3):\r\n            if not l:\r\n                return l\r\n            minValue = min(l)\r\n            maxValue = max(l)\r\n            bucketNum = (maxValue - minValue)//bucketSize + 1\r\n            buckets = [[] for i in range(bucketNum)]\r\n            for i in l:\r\n                buckets[(i-minValue)//bucketSize].append(i)\r\n\r\n            l_return = []\r\n\r\n            for i in range(bucketNum):\r\n                buckets[i] = insertSort(buckets[i])\r\n                l_return.extend(buckets[i])\r\n\r\n            return l_return\r\n            \r\n# 二、性能测试\r\n\r\n使用 profile 进行性能分析:\r\n\r\n* ncalls：表示函数调用的次数；\r\n* tottime：表示指定函数的总的运行时间，除掉函数中调用子函数的运行时间；\r\n* percall：（第一个 percall）等于 tottime/ncalls；\r\n* cumtime：表示该函数及其所有子函数的调用运行的时间，即函数开始调用到返回的时间；\r\n* percall：（第二个 percall）即函数运行一次的平均时间，等于 cumtime/ncalls；\r\n* filename:lineno(function)：每个函数调用的具体信息；\r\n\r\n        #coding:utf-8\r\n        import profile\r\n\r\n        l=[i for i in range(10000,0,-1)]\r\n        l=l+l\r\n        def testSort():\r\n            \'\'\'\r\n            from bubbleSort import bubbleSort\r\n            lb = bubbleSort(l)\r\n\r\n            from selectionSort import selectionSort \r\n            lb = selectionSort(l)\r\n\r\n            from insertSort import insertSort\r\n            lb = insertSort(l)\r\n\r\n            from shellSort import shellSort\r\n            lb = shellSort(l)\r\n            \'\'\'\r\n            \'\'\'\r\n            from mergeSort import mergeSort\r\n            lb = mergeSort(l)\r\n\r\n            from quickSort import quickSort\r\n            lb = quickSort(l)\r\n\r\n            from heapSort import heapSort\r\n            lb = heapSort(l)\r\n\r\n            from countingSort import countingSort\r\n            lb = countingSort(l)\r\n\r\n            from radixSort() import radixSort\r\n            lb = radixSort(l)\r\n\r\n            \'\'\'\r\n            from bucketSort import bucketSort\r\n            lb = bucketSort(l)\r\n\r\n        if __name__ == \'__main__\':\r\n            profile.run(\'testSort()\')\r\n\r\n性能结果：\r\n\r\n       ncalls  tottime  percall  cumtime  percall filename:lineno(function)\r\n            bubbleSort:\r\n            1    0.007    0.007   11.582   11.582 testSort.py:6(testSort)\r\n            selsectionSort:\r\n            1    0.006    0.006    8.093    8.093 testSort.py:6(testSort)\r\n            insertSort:\r\n            1    0.007    0.007   15.653   15.653 testSort.py:6(testSort)\r\n            shellSort:\r\n            1    0.006    0.006   14.572   14.572 testSort.py:6(testSort)\r\n            mergeSort:\r\n            1    0.007    0.007    1.570    1.570 testSort.py:6(testSort)\r\n            quickSort:\r\n            1    0.008    0.008    0.408    0.408 testSort.py:6(testSort)\r\n            heapSort:\r\n            1    0.007    0.007    0.762    0.762 testSort.py:6(testSort)\r\n            countingSort:\r\n            1    0.019    0.019    0.034    0.034 testSort.py:6(testSort)\r\n            radixSort:\r\n            1    0.007    0.007    0.268    0.268 testSort.py:6(testSort)\r\n            bucketSort:\r\n            1    0.006    0.006    0.142    0.142 testSort.py:6(testSort)\r\n','<h1>一、算法及程序实现</h1>\n<h2>0 参考：</h2>\n<ul>\n<li><a href=\"https://www.cnblogs.com/onepixel/articles/7674659.html\" rel=\"nofollow\">十大经典排序算法（动图演示）</a></li>\n<li>《算法导论》</li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-python-optim/\" rel=\"nofollow\">Python 代码性能优化技巧</a></li>\n</ul>\n<h2>1 冒泡</h2>\n<ul>\n<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个；</li>\n<li>重复步骤1~3，直到排序完成。<pre><code>def bubbleSort(l):\n    for i in range(len(l)-1):\n        for j in range(i+1,len(l)):\n            if l[i]&gt;l[j]:\n                l[i],l[j]=l[j],l[i]\n    return l\n</code></pre>\n</li>\n</ul>\n<p></p>\n<h2>2 选择排序</h2>\n<ul>\n<li>在未排序序列中找到最小元素，存放到排序序列的末尾位置</li>\n<li>然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。</li>\n<li>不断重复，直到所有元素均排序完毕。 <pre><code>#coding:utf-8\ndef selectionSort(l):\n    for i in range(len(l)-1):\n        Index = i#无序区的起始点\n        m = i\n        for j in range(Index,len(l)):\n            if l[j]&lt;l[m]:\n                m=j\n        if not m==Index:\n            l[m],l[Index] = l[Index],l[m]\n    return l\n</code></pre>\n</li>\n</ul>\n<h2>3 插入排序（Insertion Sort）</h2>\n<ul>\n<li>从第一个元素开始，该元素可以认为已经被排序；</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>\n<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>\n<li>将新元素插入到该位置后；</li>\n<li>重复步骤2~5。<pre><code>def insertSort(l):\n    for i in range(1,len(l)):\n        Index = i\n        for j in range(i-1,-1,-1):\n            if l[j]&gt;l[Index]:\n                l[j],l[Index]=l[Index],l[j]\n                Index -= 1\n            else:\n                continue\n    return l\n</code></pre>\n</li>\n</ul>\n<h2>4 希尔排序（Shell Sort）</h2>\n<p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>\n<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>\n<ul>\n<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>\n<li>按增量序列个数k，对序列进行k 趟排序；</li>\n<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<pre><code>def shellSort(l):\n    gap = len(l)/2\n    while(gap):\n        for i in range(gap):\n            for j in range(gap+i,len(l),gap):\n                Index = j\n                for k in range(j-gap,-1,-gap):\n                    if l[Index]&lt;l[k]:\n                        l[Index],l[k]=l[k],l[Index]\n                        Index-=1\n                    else:\n                        continue\n        gap /= 2\n    return l\n</code></pre>\n</li>\n</ul>\n<h2>5 归并排序（Merge Sort）</h2>\n<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>\n<ul>\n<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>\n<li>对这两个子序列分别采用归并排序；</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列。<pre><code>def mergeSort(l):\n    length = len(l)\n    if length&lt;=1:\n        return l\n    l1 = mergeSort(l[:length/2])\n    l2 = mergeSort(l[length/2:])\n    i=0\n    j=0\n    l_return = []\n    while 1:\n        if i&gt;=len(l1):\n            l_return.extend(l2[j:])\n            break\n        if j&gt;=len(l2):\n            l_return.extend(l1[i:])\n            break\n        if l1[i]&lt;l2[j]:\n            l_return.append(l1[i])\n            i += 1\n        else:\n            l_return.append(l2[j])\n            j += 1\n    return l_return\n</code></pre>\n</li>\n</ul>\n<h2>6 快速排序（Quick Sort）</h2>\n<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>\n<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>\n<ul>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。<pre><code>def quickSort(l):\n    if len(l)&lt;=1:\n        return l\n    i=1\n    j=len(l)-1\n    while 1:\n        for q in xrange(j,-1,-1):\n            if l[q]&lt;=l[0]:\n                break\n        j = q\n        for p in xrange(i,len(l)):\n            if l[p]&gt;l[0]:\n                break\n        i = p\n        if i&gt;=j:\n            break\n        l[i],l[j] = l[j],l[i]\n    if j!=0:\n        l[0],l[j]=l[j],l[0]\n    return quickSort(l[:q])+[l[q]]+quickSort(l[q+1:])\n</code></pre>\n</li>\n</ul>\n<h2>7 堆排序（Heap Sort）</h2>\n<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>\n<ul>\n<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>\n<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>\n<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<pre><code>length = 0\n\ndef buildMaxHeap(l):\n    global length\n    length = len(l)\n    for i in range(length/2-1, -1, -1):\n        maxHeapify(l, i)\n\ndef maxHeapify(l,i):\n    left = 2*i +1\n    right = 2*i +2\n    largest = i\n\n    if left&lt;length and l[left]&gt;l[largest]:\n        largest = left\n    if right&lt;length and l[right]&gt;l[largest]:\n        largest = right\n    if largest != i:\n        l[i], l[largest] = l[largest], l[i]\n        maxHeapify(l,largest)\n\ndef heapSort(l):\n    buildMaxHeap(l)\n    global length\n\n    for i in range(len(l)-1,-1,-1):\n        l[0],l[i] = l[i],l[0]\n        length -= 1\n        maxHeapify(l,0)\n    return l\n</code></pre>\n</li>\n</ul>\n<h2>8 计数排序（Counting Sort）</h2>\n<p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>\n<ul>\n<li>找出待排序的数组中最大和最小的元素；</li>\n<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>\n<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>\n<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。<pre><code>def countingSort(a, maxValue):\n    c = [0] * (maxValue+1)\n    b = [0] * len(a)\n    for i in xrange(len(a)):\n        c[a[i]] += 1\n    for i in xrange(1,maxValue+1):\n        c[i] += c[i-1]\n    for j in xrange(len(a)-1,-1,-1):\n        b[c[a[j]]-1] = a[j]\n        c[a[j]] -= 1\n    return b\n</code></pre>\n</li>\n</ul>\n<h2>9 基数排序（Radix Sort）</h2>\n<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>\n<ul>\n<li>取得数组中的最大数，并取得位数；</li>\n<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>\n<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；<pre><code>def radixSort(l):\n    d = len(str(max(l)))\n    for i in range(d):\n        buf = [[] for m in range(10)]\n        for n in l:\n            k = n//(10**i)%10\n            buf[k].append(n)\n        l = []\n        for j in range(10):\n            l.extend(buf[j])\n    return l\n</code></pre>\n</li>\n</ul>\n<h2>10 桶排序（Bucket Sort）</h2>\n<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>\n<ul>\n<li>设置一个定量的数组当作空桶；</li>\n<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>\n<li>对每个不是空的桶进行排序；</li>\n<li>从不是空的桶里把排好序的数据拼接起来。<pre><code>from insertSort import insertSort\ndef bucketSort(l,bucketSize = 3):\n    if not l:\n        return l\n    minValue = min(l)\n    maxValue = max(l)\n    bucketNum = (maxValue - minValue)//bucketSize + 1\n    buckets = [[] for i in range(bucketNum)]\n    for i in l:\n        buckets[(i-minValue)//bucketSize].append(i)\n\n    l_return = []\n\n    for i in range(bucketNum):\n        buckets[i] = insertSort(buckets[i])\n        l_return.extend(buckets[i])\n\n    return l_return\n</code></pre>\n</li>\n</ul>\n<h1>二、性能测试</h1>\n<p>使用 profile 进行性能分析:</p>\n<ul>\n<li>ncalls：表示函数调用的次数；</li>\n<li>tottime：表示指定函数的总的运行时间，除掉函数中调用子函数的运行时间；</li>\n<li>percall：（第一个 percall）等于 tottime/ncalls；</li>\n<li>cumtime：表示该函数及其所有子函数的调用运行的时间，即函数开始调用到返回的时间；</li>\n<li>percall：（第二个 percall）即函数运行一次的平均时间，等于 cumtime/ncalls；</li>\n<li>filename:lineno(function)：每个函数调用的具体信息；<pre><code>#coding:utf-8\nimport profile\n\nl=[i for i in range(10000,0,-1)]\nl=l+l\ndef testSort():\n    \'\'\'\n    from bubbleSort import bubbleSort\n    lb = bubbleSort(l)\n\n    from selectionSort import selectionSort \n    lb = selectionSort(l)\n\n    from insertSort import insertSort\n    lb = insertSort(l)\n\n    from shellSort import shellSort\n    lb = shellSort(l)\n    \'\'\'\n    \'\'\'\n    from mergeSort import mergeSort\n    lb = mergeSort(l)\n\n    from quickSort import quickSort\n    lb = quickSort(l)\n\n    from heapSort import heapSort\n    lb = heapSort(l)\n\n    from countingSort import countingSort\n    lb = countingSort(l)\n\n    from radixSort() import radixSort\n    lb = radixSort(l)\n\n    \'\'\'\n    from bucketSort import bucketSort\n    lb = bucketSort(l)\n\nif __name__ == \'__main__\':\n    profile.run(\'testSort()\')\n</code></pre>\n</li>\n</ul>\n<p>性能结果：</p>\n<pre><code>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n        bubbleSort:\n        1    0.007    0.007   11.582   11.582 <a href=\"http://testSort.py:6\" rel=\"nofollow\">testSort.py:6</a>(testSort)\n        selsectionSort:\n        1    0.006    0.006    8.093    8.093 <a href=\"http://testSort.py:6\" rel=\"nofollow\">testSort.py:6</a>(testSort)\n        insertSort:\n        1    0.007    0.007   15.653   15.653 <a href=\"http://testSort.py:6\" rel=\"nofollow\">testSort.py:6</a>(testSort)\n        shellSort:\n        1    0.006    0.006   14.572   14.572 <a href=\"http://testSort.py:6\" rel=\"nofollow\">testSort.py:6</a>(testSort)\n        mergeSort:\n        1    0.007    0.007    1.570    1.570 <a href=\"http://testSort.py:6\" rel=\"nofollow\">testSort.py:6</a>(testSort)\n        quickSort:\n        1    0.008    0.008    0.408    0.408 <a href=\"http://testSort.py:6\" rel=\"nofollow\">testSort.py:6</a>(testSort)\n        heapSort:\n        1    0.007    0.007    0.762    0.762 <a href=\"http://testSort.py:6\" rel=\"nofollow\">testSort.py:6</a>(testSort)\n        countingSort:\n        1    0.019    0.019    0.034    0.034 <a href=\"http://testSort.py:6\" rel=\"nofollow\">testSort.py:6</a>(testSort)\n        radixSort:\n        1    0.007    0.007    0.268    0.268 <a href=\"http://testSort.py:6\" rel=\"nofollow\">testSort.py:6</a>(testSort)\n        bucketSort:\n        1    0.006    0.006    0.142    0.142 <a href=\"http://testSort.py:6\" rel=\"nofollow\">testSort.py:6</a>(testSort)\n</code></pre>','2018-05-25 06:40:32',888);
/*!40000 ALTER TABLE `posts` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `roles`
--

DROP TABLE IF EXISTS `roles`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `roles` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(64) DEFAULT NULL,
  `default` tinyint(1) DEFAULT NULL,
  `permissions` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`),
  KEY `ix_roles_default` (`default`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `roles`
--

LOCK TABLES `roles` WRITE;
/*!40000 ALTER TABLE `roles` DISABLE KEYS */;
INSERT INTO `roles` VALUES (1,'Moderator',0,15),(2,'Administrator',0,31),(3,'User',1,7);
/*!40000 ALTER TABLE `roles` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `users` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `email` varchar(64) DEFAULT NULL,
  `username` varchar(64) DEFAULT NULL,
  `role_id` int(11) DEFAULT NULL,
  `password_hash` varchar(128) DEFAULT NULL,
  `confirmed` tinyint(1) DEFAULT NULL,
  `name` varchar(64) DEFAULT NULL,
  `location` varchar(64) DEFAULT NULL,
  `about_me` text,
  `member_since` datetime DEFAULT NULL,
  `last_seen` datetime DEFAULT NULL,
  `avatar_hash` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `ix_users_email` (`email`),
  UNIQUE KEY `ix_users_username` (`username`),
  KEY `role_id` (`role_id`),
  CONSTRAINT `users_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `roles` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=890 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` VALUES (888,'bingo@example.com','bingo',1,'pbkdf2:sha256:50000$xOTr7brY$8d7f2571f88e31c075436aae294ea5c32d813d390fb237463d8ca17ec9b42b8d',1,'bingo',NULL,NULL,'2018-05-10 08:32:25','2018-05-25 08:38:14','29657eb7002063e8820e64edfc758a99'),(889,'a@b.com','a',3,'pbkdf2:sha256:50000$3MVFS7Bv$e3b7bf3a9182c99296f567562e9bd7a6214f1f035cd6052c216473b7a7174a8f',0,NULL,NULL,NULL,'2018-06-06 07:44:52','2018-06-06 07:44:52','357a20e8c56e69d6f9734d23ef9517e8');
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2018-06-25  1:35:59
